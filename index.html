<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Letterboxd Film Recommender</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState } = React;
        
        const FilmRecommender = () => {
          const [username, setUsername] = useState('');
          const [ratingsData, setRatingsData] = useState(null);
          const [watchlistData, setWatchlistData] = useState(null);
          const [enrichedFilms, setEnrichedFilms] = useState(null);
          const [recommendations, setRecommendations] = useState([]);
          const [loading, setLoading] = useState(false);
          const [error, setError] = useState('');
          const [progress, setProgress] = useState('');
          const [useWatchlistOnly, setUseWatchlistOnly] = useState(false);
          const [excludeWatchlist, setExcludeWatchlist] = useState(false);
          const [weights, setWeights] = useState({
            director: 0.25,
            genre: 0.25,
            year: 0.15,
            language: 0.15,
            runtime: 0.1,
            popularity: 0.1
          });

          const TMDB_API_KEY = 'b706b941e23c5b713ba58475cfd4ae6f';
          const TMDB_BASE_URL = 'https://api.themoviedb.org/3';

          const parseCSV = (text) => {
            const lines = text.trim().split('\n');
            const headers = lines[0].split(',').map(h => h.trim());
            return lines.slice(1).map(line => {
              const values = line.match(/(".*?"|[^,]+)(?=\s*,|\s*$)/g) || [];
              const obj = {};
              headers.forEach((header, i) => {
                obj[header] = values[i]?.replace(/^"|"$/g, '').trim();
              });
              return obj;
            });
          };

          const fetchLetterboxdData = async (username, type = 'ratings') => {
            try {
              setProgress(`Fetching ${type} from Letterboxd...`);
              
              const proxyUrl = 'https://api.allorigins.win/raw?url=';
              const letterboxdUrl = type === 'ratings' 
                ? `https://letterboxd.com/${username}/films/` 
                : `https://letterboxd.com/${username}/watchlist/`;
              
              const response = await fetch(proxyUrl + encodeURIComponent(letterboxdUrl));
              const html = await response.text();
              
              const parser = new DOMParser();
              const doc = parser.parseFromString(html, 'text/html');
              
              const films = [];
              const filmElements = doc.querySelectorAll('li.poster-container');
              
              if (filmElements.length === 0) {
                throw new Error(`No ${type} found. Check if the username is correct and the profile is public.`);
              }
              
              filmElements.forEach(el => {
                const filmDiv = el.querySelector('div[data-film-slug]');
                const filmName = filmDiv?.getAttribute('data-film-name');
                const filmYear = filmDiv?.getAttribute('data-film-release-year');
                const rating = el.querySelector('.rating')?.className.match(/rated-(\d+)/)?.[1];
                
                if (filmName && filmYear) {
                  const filmData = {
                    Name: filmName,
                    Year: filmYear,
                    'Letterboxd URI': `https://letterboxd.com/film/${filmDiv.getAttribute('data-film-slug')}/`
                  };
                  
                  if (type === 'ratings' && rating) {
                    filmData.Rating = (parseInt(rating) / 2).toString();
                  }
                  
                  films.push(filmData);
                }
              });
              
              // For ratings, we need to fetch all pages
              if (type === 'ratings') {
                let page = 2;
                let hasMore = true;
                
                while (hasMore && page <= 10) {
                  setProgress(`Fetching ${type} page ${page}...`);
                  const pageUrl = `${letterboxdUrl}page/${page}/`;
                  const pageResponse = await fetch(proxyUrl + encodeURIComponent(pageUrl));
                  const pageHtml = await pageResponse.text();
                  const pageDoc = parser.parseFromString(pageHtml, 'text/html');
                  const pageFilms = pageDoc.querySelectorAll('li.poster-container');
                  
                  if (pageFilms.length === 0) {
                    hasMore = false;
                  } else {
                    pageFilms.forEach(el => {
                      const filmDiv = el.querySelector('div[data-film-slug]');
                      const filmName = filmDiv?.getAttribute('data-film-name');
                      const filmYear = filmDiv?.getAttribute('data-film-release-year');
                      const rating = el.querySelector('.rating')?.className.match(/rated-(\d+)/)?.[1];
                      
                      if (filmName && filmYear) {
                        const filmData = {
                          Name: filmName,
                          Year: filmYear,
                          'Letterboxd URI': `https://letterboxd.com/film/${filmDiv.getAttribute('data-film-slug')}/`
                        };
                        
                        if (rating) {
                          filmData.Rating = (parseInt(rating) / 2).toString();
                        }
                        
                        films.push(filmData);
                      }
                    });
                    page++;
                  }
                  
                  await new Promise(resolve => setTimeout(resolve, 500));
                }
              }
              
              return films;
            } catch (err) {
              throw new Error(`Failed to fetch ${type}: ${err.message}`);
            }
          };

          const handleFetchData = async () => {
            if (!username.trim()) {
              setError('Please enter a Letterboxd username');
              return;
            }
            
            setLoading(true);
            setError('');
            setProgress('');
            setRatingsData(null);
            setWatchlistData(null);
            setEnrichedFilms(null);
            setRecommendations([]);
            
            try {
              const ratings = await fetchLetterboxdData(username.trim(), 'ratings');
              setRatingsData(ratings);
              
              try {
                const watchlist = await fetchLetterboxdData(username.trim(), 'watchlist');
                setWatchlistData(watchlist);
              } catch (err) {
                console.log('Watchlist fetch failed, continuing without it:', err);
              }
              
              setProgress('');
              setLoading(false);
            } catch (err) {
              setError(err.message);
              setProgress('');
              setLoading(false);
            }
          };

          const handleFileUpload = async (e, type) => {
            const file = e.target.files[0];
            if (!file) return;

            const text = await file.text();
            const data = parseCSV(text);
            
            if (type === 'ratings') {
              setRatingsData(data);
              setEnrichedFilms(null);
              setRecommendations([]);
            } else {
              setWatchlistData(data);
            }
          };

          const searchTMDB = async (title, year) => {
            try {
              const response = await fetch(
                `${TMDB_BASE_URL}/search/movie?api_key=${TMDB_API_KEY}&query=${encodeURIComponent(title)}&year=${year}`
              );
              const data = await response.json();
              return data.results?.[0] || null;
            } catch (err) {
              console.error('TMDB search error:', err);
              return null;
            }
          };

          const getMovieDetails = async (movieId) => {
            try {
              const [details, credits] = await Promise.all([
                fetch(`${TMDB_BASE_URL}/movie/${movieId}?api_key=${TMDB_API_KEY}`).then(r => r.json()),
                fetch(`${TMDB_BASE_URL}/movie/${movieId}/credits?api_key=${TMDB_API_KEY}`).then(r => r.json())
              ]);
              
              return {
                ...details,
                director: credits.crew?.find(p => p.job === 'Director')?.name || 'Unknown'
              };
            } catch (err) {
              console.error('Movie details error:', err);
              return null;
            }
          };

          const enrichFilmData = async () => {
            if (!ratingsData) return;
            
            setLoading(true);
            setError('');
            setProgress('');
            
            try {
              const enriched = [];
              
              for (let i = 0; i < ratingsData.length; i++) {
                const film = ratingsData[i];
                setProgress(`Processing film ${i + 1} of ${ratingsData.length}...`);
                
                const tmdbResult = await searchTMDB(film.Name, film.Year);
                if (tmdbResult) {
                  const details = await getMovieDetails(tmdbResult.id);
                  if (details) {
                    enriched.push({
                      ...film,
                      rating: parseFloat(film.Rating),
                      tmdb: details,
                      director: details.director,
                      genres: details.genres?.map(g => g.name) || [],
                      language: details.original_language || 'unknown',
                      runtime: details.runtime || 0,
                      popularity: details.popularity || 0
                    });
                  }
                }
                
                await new Promise(resolve => setTimeout(resolve, 300));
              }
              
              setEnrichedFilms(enriched);
              setProgress('');
              setLoading(false);
            } catch (err) {
              setError('Error fetching film data: ' + err.message);
              setProgress('');
              setLoading(false);
            }
          };

          const calculateSimilarity = (film1, film2) => {
            let score = 0;
            
            if (film1.director === film2.director && film1.director !== 'Unknown') {
              score += weights.director;
            }
            
            const genres1 = new Set(film1.genres);
            const genres2 = new Set(film2.genres);
            const genreOverlap = [...genres1].filter(g => genres2.has(g)).length;
            const genreScore = genres1.size > 0 ? genreOverlap / genres1.size : 0;
            score += weights.genre * genreScore;
            
            const yearDiff = Math.abs(parseInt(film1.Year) - parseInt(film2.Year));
            const yearScore = Math.max(0, 1 - yearDiff / 50);
            score += weights.year * yearScore;
            
            if (film1.language === film2.language) {
              score += weights.language;
            }
            
            const runtimeDiff = Math.abs(film1.runtime - film2.runtime);
            const runtimeScore = Math.max(0, 1 - runtimeDiff / 120);
            score += weights.runtime * runtimeScore;
            
            const popDiff = Math.abs(Math.log(film1.popularity + 1) - Math.log(film2.popularity + 1));
            const popScore = Math.max(0, 1 - popDiff / 5);
            score += weights.popularity * popScore;
            
            return score;
          };

          const generateRecommendations = async () => {
            if (!enrichedFilms || enrichedFilms.length === 0) return;
            
            setLoading(true);
            setProgress('');
            setError('');
            
            try {
              const highRated = enrichedFilms.filter(f => f.rating >= 4);
              
              if (highRated.length === 0) {
                setError('No films rated 4 stars or higher found. Try rating some films higher!');
                setLoading(false);
                return;
              }
              
              let candidates = [];
              
              if (useWatchlistOnly && watchlistData) {
                setProgress('Analyzing watchlist films...');
                for (let i = 0; i < watchlistData.length; i++) {
                  const wFilm = watchlistData[i];
                  setProgress(`Processing watchlist film ${i + 1} of ${watchlistData.length}...`);
                  
                  const tmdbResult = await searchTMDB(wFilm.Name, wFilm.Year);
                  if (tmdbResult) {
                    const details = await getMovieDetails(tmdbResult.id);
                    if (details) {
                      candidates.push({
                        ...wFilm,
                        tmdb: details,
                        director: details.director,
                        genres: details.genres?.map(g => g.name) || [],
                        language: details.original_language || 'unknown',
                        runtime: details.runtime || 0,
                        popularity: details.popularity || 0
                      });
                    }
                  }
                  await new Promise(resolve => setTimeout(resolve, 300));
                }
              } else {
                setProgress('Finding similar films...');
                const topDirectors = [...new Set(highRated.map(f => f.director))].slice(0, 5);
                
                for (let i = 0; i < topDirectors.length; i++) {
                  const director = topDirectors[i];
                  if (director === 'Unknown') continue;
                  
                  setProgress(`Searching films by ${director}...`);
                  
                  const response = await fetch(
                    `${TMDB_BASE_URL}/search/person?api_key=${TMDB_API_KEY}&query=${encodeURIComponent(director)}`
                  );
                  const data = await response.json();
                  const person = data.results?.[0];
                  
                  if (person) {
                    const creditsRes = await fetch(
                      `${TMDB_BASE_URL}/person/${person.id}/movie_credits?api_key=${TMDB_API_KEY}`
                    );
                    const credits = await creditsRes.json();
                    const directed = credits.crew?.filter(c => c.job === 'Director').slice(0, 10) || [];
                    
                    for (const movie of directed) {
                      const details = await getMovieDetails(movie.id);
                      if (details) {
                        candidates.push({
                          Name: details.title,
                          Year: details.release_date?.split('-')[0] || '',
                          tmdb: details,
                          director: details.director,
                          genres: details.genres?.map(g => g.name) || [],
                          language: details.original_language || 'unknown',
                          runtime: details.runtime || 0,
                          popularity: details.popularity || 0
                        });
                      }
                      await new Promise(resolve => setTimeout(resolve, 300));
                    }
                  }
                }
              }
              
              setProgress('Calculating similarity scores...');
              
              const watchedTitles = new Set(enrichedFilms.map(f => `${f.Name}-${f.Year}`));
              candidates = candidates.filter(c => !watchedTitles.has(`${c.Name}-${c.Year}`));
              
              if (excludeWatchlist && watchlistData) {
                const watchlistTitles = new Set(watchlistData.map(w => `${w.Name}-${w.Year}`));
                candidates = candidates.filter(c => !watchlistTitles.has(`${c.Name}-${c.Year}`));
              }
              
              const scored = candidates.map(candidate => {
                const scores = highRated.map(rated => ({
                  film: rated,
                  similarity: calculateSimilarity(rated, candidate)
                }));
                
                const topScores = scores.sort((a, b) => b.similarity - a.similarity).slice(0, 3);
                const avgScore = topScores.reduce((sum, s) => sum + s.similarity, 0) / topScores.length;
                
                return {
                  ...candidate,
                  score: avgScore,
                  matchedFilms: topScores.map(s => ({ title: s.film.Name, rating: s.film.rating }))
                };
              });
              
              const unique = Array.from(
                new Map(scored.map(s => [`${s.Name}-${s.Year}`, s])).values()
              );
              
              setRecommendations(unique.sort((a, b) => b.score - a.score).slice(0, 20));
              setProgress('');
              setLoading(false);
            } catch (err) {
              setError('Error generating recommendations: ' + err.message);
              setProgress('');
              setLoading(false);
            }
          };

          return (
            <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 text-white p-4 md:p-8">
              <div className="max-w-6xl mx-auto">
                <div className="text-center mb-8 md:mb-12">
                  <div className="text-5xl mb-4">üé¨</div>
                  <h1 className="text-3xl md:text-4xl font-bold mb-2">Letterboxd Film Recommender</h1>
                  <p className="text-slate-300">Enter your username or upload CSVs to discover films</p>
                </div>

                {!ratingsData && (
                  <div className="bg-slate-800/50 backdrop-blur p-6 rounded-lg border border-slate-700 mb-8">
                    <h3 className="text-xl font-semibold mb-4">Option 1: Enter Letterboxd Username</h3>
                    <div className="flex gap-2 mb-6">
                      <input
                        type="text"
                        value={username}
                        onChange={(e) => setUsername(e.target.value)}
                        placeholder="Your Letterboxd username"
                        className="flex-1 p-3 bg-slate-700 rounded border border-slate-600 text-white"
                        onKeyPress={(e) => e.key === 'Enter' && handleFetchData()}
                      />
                      <button
                        onClick={handleFetchData}
                        disabled={loading}
                        className="bg-purple-600 hover:bg-purple-700 disabled:bg-slate-600 px-6 py-3 rounded font-semibold transition"
                      >
                        {loading ? 'Fetching...' : 'Fetch Data'}
                      </button>
                    </div>
                    
                    <div className="text-center text-slate-400 my-4">OR</div>
                    
                    <h3 className="text-xl font-semibold mb-4">Option 2: Upload CSV Files</h3>
                    <div className="grid md:grid-cols-2 gap-4">
                      <div>
                        <label className="block text-sm mb-2">üì§ Ratings CSV (Required)</label>
                        <input
                          type="file"
                          accept=".csv"
                          onChange={(e) => handleFileUpload(e, 'ratings')}
                          className="w-full p-2 bg-slate-700 rounded border border-slate-600 text-sm"
                        />
                      </div>
                      <div>
                        <label className="block text-sm mb-2">üìã Watchlist CSV (Optional)</label>
                        <input
                          type="file"
                          accept=".csv"
                          onChange={(e) => handleFileUpload(e, 'watchlist')}
                          className="w-full p-2 bg-slate-700 rounded border border-slate-600 text-sm"
                        />
                      </div>
                    </div>
                  </div>
                )}

                {ratingsData && !enrichedFilms && (
                  <div className="bg-slate-800/50 backdrop-blur p-6 rounded-lg border border-slate-700 mb-8">
                    <div className="mb-4">
                      <p className="text-green-400 mb-2">‚úì {ratingsData.length} rated films loaded</p>
                      {watchlistData && <p className="text-green-400">‚úì {watchlistData.length} watchlist films loaded</p>}
                    </div>
                    <button
                      onClick={enrichFilmData}
                      disabled={loading}
                      className="w-full bg-purple-600 hover:bg-purple-700 disabled:bg-slate-600 p-4 rounded-lg font-semibold transition"
                    >
                      {loading ? progress || 'Fetching film data...' : 'Step 1: Analyze My Ratings'}
                    </button>
                  </div>
                )}

                {enrichedFilms && (
                  <>
                    <div className="bg-slate-800/50 backdrop-blur p-4 md:p-6 rounded-lg border border-slate-700 mb-6 md:mb-8">
                      <h3 className="text-lg md:text-xl font-semibold mb-4 flex items-center gap-2">
                        ‚öôÔ∏è Recommendation Settings
                      </h3>
                      
                      <div className="grid grid-cols-2 md:grid-cols-3 gap-3 md:gap-4 mb-4 md:mb-6">
                        {Object.entries(weights).map(([key, value]) => (
                          <div key={key}>
                            <label className="block text-xs md:text-sm mb-2 capitalize">{key}</label>
                            <input
                              type="range"
                              min="0"
                              max="1"
                              step="0.05"
                              value={value}
                              onChange={(e) => setWeights({...weights, [key]: parseFloat(e.target.value)})}
                              className="w-full"
                            />
                            <span className="text-xs text-slate-400">{value.toFixed(2)}</span>
                          </div>
                        ))}
                      </div>

                      <div className="flex flex-col md:flex-row gap-3 md:gap-4 mb-4 text-sm">
                        <label className="flex items-center gap-2">
                          <input
                            type="checkbox"
                            checked={useWatchlistOnly}
                            onChange={(e) => setUseWatchlistOnly(e.target.checked)}
                            disabled={!watchlistData}
                            className="w-4 h-4"
                          />
                          <span>Only recommend from watchlist</span>
                        </label>
                        
                        <label className="flex items-center gap-2">
                          <input
                            type="checkbox"
                            checked={excludeWatchlist}
                            onChange={(e) => setExcludeWatchlist(e.target.checked)}
                            disabled={!watchlistData || useWatchlistOnly}
                            className="w-4 h-4"
                          />
                          <span>Exclude watchlist films</span>
                        </label>
                      </div>

                      <button
                        onClick={generateRecommendations}
                        disabled={loading}
                        className="w-full bg-green-600 hover:bg-green-700 disabled:bg-slate-600 p-3 rounded-lg font-semibold transition"
                      >
                        {loading ? progress || 'Generating recommendations...' : 'Step 2: Get Recommendations'}
                      </button>
                    </div>

                    {recommendations.length > 0 && (
                      <div>
                        <h3 className="text-xl md:text-2xl font-bold mb-4 md:mb-6 flex items-center gap-2">
                          üìà Your Recommendations
                        </h3>
                        
                        <div className="grid gap-4">
                          {recommendations.map((rec, i) => (
                            <div key={i} className="bg-slate-800/50 backdrop-blur p-4 md:p-6 rounded-lg border border-slate-700 hover:border-purple-500 transition">
                              <div className="flex justify-between items-start mb-3">
                                <div>
                                  <h4 className="text-lg md:text-xl font-semibold">{rec.Name} ({rec.Year})</h4>
                                  <p className="text-sm text-slate-400">Directed by {rec.director}</p>
                                </div>
                                <div className="text-right">
                                  <div className="text-xl md:text-2xl font-bold text-purple-400">
                                    {(rec.score * 100).toFixed(0)}%
                                  </div>
                                  <div className="text-xs text-slate-400">match</div>
                                </div>
                              </div>
                              
                              <div className="flex flex-wrap gap-2 mb-3">
                                {rec.genres.map(g => (
                                  <span key={g} className="px-2 py-1 bg-slate-700 rounded text-xs">
                                    {g}
                                  </span>
                                ))}
                              </div>
                              
                              <p className="text-xs md:text-sm text-slate-300 mb-2">
                                {rec.tmdb.overview?.slice(0, 200)}{rec.tmdb.overview?.length > 200 ? '...' : ''}
                              </p>
                              
                              <div className="text-xs text-slate-400">
                                Similar to: {rec.matchedFilms.slice(0, 2).map(m => m.title).join(', ')}
                              </div>
                            </div>
                          ))}
                        </div>
                      </div>
                    )}
                  </>
                )}

                {error && (
                  <div className="bg-red-900/50 border border-red-700 p-4 rounded-lg text-sm">
                    {error}
                  </div>
                )}
                
                {progress && (
                  <div className="bg-blue-900/50 border border-blue-700 p-4 rounded-lg text-sm text-center">
                    {progress}
                  </div>
                )}
                
                <footer className="mt-12 text-center text-sm text-slate-400">
                  <p>Data provided by <a href="https://www.themoviedb.org/" target="_blank" rel="noopener noreferrer" className="text-purple-400 hover:text-purple-300">TMDb</a></p>
                </footer>
              </div>
            </div>
          );
        };

        ReactDOM.render(<FilmRecommender />, document.getElementById('root'));
    </script>
</body>
</html>
